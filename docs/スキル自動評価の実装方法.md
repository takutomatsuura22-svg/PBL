# スキル自動評価の実装方法

## 📋 目次

1. [方法1: タスク完了率ベースの評価](#方法1-タスク完了率ベースの評価)
2. [方法2: 難易度適応度ベースの評価](#方法2-難易度適応度ベースの評価)
3. [方法3: 完了速度ベースの評価](#方法3-完了速度ベースの評価)
4. [方法4: MBTI特性による補正](#方法4-mbti特性による補正)
5. [方法5: 複合指標による総合評価](#方法5-複合指標による総合評価)
6. [方法6: 時系列成長の追跡](#方法6-時系列成長の追跡)
7. [方法7: チーム内比較による相対評価](#方法7-チーム内比較による相対評価)
8. [方法8: レビュー評価の活用](#方法8-レビュー評価の活用)
9. [方法9: 自己評価との比較](#方法9-自己評価との比較)
10. [方法10: タスクパターン分析](#方法10-タスクパターン分析)

---

## 方法1: タスク完了率ベースの評価

### 概要
カテゴリ別のタスク完了率からスキルを推定

### 実装内容

**計算ロジック**:
```typescript
function calculateSkillFromCompletionRate(
  studentId: string,
  category: '企画' | '実行' | '調整' | '探索',
  tasks: Task[]
): number {
  // そのカテゴリのタスクを抽出
  const categoryTasks = tasks.filter(t => 
    t.category === category && t.assignee_id === studentId
  )
  
  if (categoryTasks.length === 0) return 3.0 // デフォルト
  
  // 完了率を計算
  const completed = categoryTasks.filter(t => t.status === 'completed').length
  const completionRate = completed / categoryTasks.length
  
  // 完了率を1-5スケールに変換
  // 完了率100% = 5.0, 0% = 1.0
  const skillScore = 1 + (completionRate * 4)
  
  return Math.max(1, Math.min(5, skillScore))
}
```

**重み付け**:
- タスク数が多いほど信頼度が高い
- 最低3タスク以上で評価（それ以下はデフォルト値）

**メリット**:
- 実装が簡単
- 直感的で理解しやすい
- 既存のタスクデータで計算可能

**デメリット**:
- タスクの難易度を考慮していない
- 完了速度や品質を考慮していない

---

## 方法2: 難易度適応度ベースの評価

### 概要
どの難易度レベルのタスクを成功させられるかでスキルを評価

### 実装内容

**計算ロジック**:
```typescript
function calculateSkillFromDifficultyAdaptation(
  studentId: string,
  category: '企画' | '実行' | '調整' | '探索',
  tasks: Task[]
): number {
  const categoryTasks = tasks.filter(t => 
    t.category === category && 
    t.assignee_id === studentId &&
    t.status === 'completed'
  )
  
  if (categoryTasks.length === 0) return 3.0
  
  // 完了したタスクの難易度の平均
  const avgDifficulty = categoryTasks.reduce((sum, t) => sum + t.difficulty, 0) / categoryTasks.length
  
  // 難易度をそのままスキルスコアとして使用
  // 難易度5のタスクを完了 = スキル5
  return Math.max(1, Math.min(5, Math.round(avgDifficulty * 10) / 10))
}
```

**改善版（成功率も考慮）**:
```typescript
function calculateSkillFromDifficultySuccess(
  studentId: string,
  category: string,
  tasks: Task[]
): number {
  const categoryTasks = tasks.filter(t => 
    t.category === category && t.assignee_id === studentId
  )
  
  // 難易度別の成功率を計算
  const difficultyStats: Record<number, { attempted: number; completed: number }> = {}
  
  categoryTasks.forEach(task => {
    if (!difficultyStats[task.difficulty]) {
      difficultyStats[task.difficulty] = { attempted: 0, completed: 0 }
    }
    difficultyStats[task.difficulty].attempted++
    if (task.status === 'completed') {
      difficultyStats[task.difficulty].completed++
    }
  })
  
  // 最も高い難易度で成功率50%以上を達成できているか
  let maxSuccessfulDifficulty = 1
  for (let diff = 5; diff >= 1; diff--) {
    if (difficultyStats[diff]) {
      const successRate = difficultyStats[diff].completed / difficultyStats[diff].attempted
      if (successRate >= 0.5 && difficultyStats[diff].attempted >= 2) {
        maxSuccessfulDifficulty = diff
        break
      }
    }
  }
  
  // スキルスコア = 最大成功難易度 + 成功率ボーナス
  const overallSuccessRate = categoryTasks.filter(t => t.status === 'completed').length / categoryTasks.length
  const bonus = overallSuccessRate > 0.8 ? 0.5 : overallSuccessRate > 0.6 ? 0.3 : 0
  
  return Math.max(1, Math.min(5, maxSuccessfulDifficulty + bonus))
}
```

**メリット**:
- 難易度を考慮した評価
- 成長の段階が分かりやすい

**デメリット**:
- タスク数が少ないと評価が不安定

---

## 方法3: 完了速度ベースの評価

### 概要
タスクの完了速度（効率性）からスキルを評価

### 実装内容

**必要なデータ**:
- `start_date`: タスク開始日
- `end_date`: タスク完了日（または`deadline`）
- `estimated_hours`: 推定時間

**計算ロジック**:
```typescript
function calculateSkillFromCompletionSpeed(
  studentId: string,
  category: string,
  tasks: Task[]
): number {
  const completedTasks = tasks.filter(t => 
    t.category === category &&
    t.assignee_id === studentId &&
    t.status === 'completed' &&
    t.start_date &&
    t.end_date
  )
  
  if (completedTasks.length === 0) return 3.0
  
  // 各タスクの効率性を計算
  const efficiencies: number[] = []
  
  completedTasks.forEach(task => {
    const startDate = new Date(task.start_date)
    const endDate = new Date(task.end_date)
    const actualHours = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24) * 8 // 1日8時間と仮定
    const estimatedHours = task.estimated_hours || actualHours
    
    // 効率性 = 推定時間 / 実際の時間
    // 1.0 = 予定通り, >1.0 = 早い, <1.0 = 遅い
    const efficiency = estimatedHours / Math.max(actualHours, 0.1)
    efficiencies.push(efficiency)
  })
  
  // 平均効率性
  const avgEfficiency = efficiencies.reduce((sum, e) => sum + e, 0) / efficiencies.length
  
  // 効率性を1-5スケールに変換
  // 効率性1.2以上 = 5.0, 1.0 = 3.0, 0.8以下 = 1.0
  let skillScore = 3.0
  if (avgEfficiency >= 1.2) {
    skillScore = 3.0 + (avgEfficiency - 1.2) * 5 // 最大5.0
  } else if (avgEfficiency >= 1.0) {
    skillScore = 3.0 + (avgEfficiency - 1.0) * 5
  } else {
    skillScore = 3.0 - (1.0 - avgEfficiency) * 10 // 最小1.0
  }
  
  return Math.max(1, Math.min(5, Math.round(skillScore * 10) / 10))
}
```

**メリット**:
- 効率性を評価できる
- 時間管理能力も反映

**デメリット**:
- 開始日・終了日のデータが必要
- 推定時間の精度に依存

---

## 方法4: MBTI特性による補正

### 概要
MBTIタイプからスキルのベース値を設定し、実績で補正

### 実装内容

**MBTI特性マッピング**:
```typescript
function getMBTISkillBase(mbti: string): {
  企画: number
  実行: number
  調整: number
  探索: number
} {
  const base = { 企画: 3.0, 実行: 3.0, 調整: 3.0, 探索: 3.0 }
  
  // E/I（外向/内向）
  if (mbti.startsWith('E')) {
    base.調整 += 0.2
    base.探索 += 0.1
  } else {
    base.企画 += 0.2
    base.実行 += 0.1
  }
  
  // S/N（感覚/直感）
  if (mbti[1] === 'S') {
    base.実行 += 0.3
    base.調整 += 0.2
    base.企画 -= 0.1
    base.探索 -= 0.1
  } else {
    base.企画 += 0.3
    base.探索 += 0.3
    base.実行 -= 0.2
    base.調整 += 0.1
  }
  
  // T/F（思考/感情）
  if (mbti[2] === 'T') {
    base.実行 += 0.1
    base.企画 += 0.1
  } else {
    base.調整 += 0.2
  }
  
  // J/P（判断/知覚）
  if (mbti[3] === 'J') {
    base.実行 += 0.1
    base.調整 += 0.1
  } else {
    base.探索 += 0.1
    base.企画 += 0.1
  }
  
  // 1-5の範囲に正規化
  Object.keys(base).forEach(key => {
    base[key] = Math.max(1, Math.min(5, Math.round(base[key] * 10) / 10))
  })
  
  return base
}
```

**実績で補正**:
```typescript
function calculateSkillWithMBTICorrection(
  student: Student,
  category: string,
  tasks: Task[]
): number {
  // MBTIベースのスキル
  const mbtiBase = getMBTISkillBase(student.MBTI)[category]
  
  // 実績ベースのスキル（方法1または方法2を使用）
  const performanceBased = calculateSkillFromCompletionRate(
    student.student_id,
    category,
    tasks
  )
  
  // 重み付け平均
  // 実績データが多いほど実績ベースの重みを大きく
  const categoryTasks = tasks.filter(t => 
    t.category === category && t.assignee_id === student.student_id
  )
  const dataPoints = categoryTasks.length
  const performanceWeight = Math.min(0.7, dataPoints / 10) // 最大70%
  const mbtiWeight = 1 - performanceWeight
  
  const finalScore = (mbtiBase * mbtiWeight) + (performanceBased * performanceWeight)
  
  return Math.max(1, Math.min(5, Math.round(finalScore * 10) / 10))
}
```

**メリット**:
- 初期値が設定できる（データが少ない場合でも評価可能）
- 実績データが増えると自動的に実績ベースにシフト

**デメリット**:
- MBTIの精度に依存
- 個人差を考慮しきれない可能性

---

## 方法5: 複合指標による総合評価

### 概要
複数の指標を組み合わせて総合的に評価

### 実装内容

**計算ロジック**:
```typescript
function calculateSkillComprehensive(
  studentId: string,
  category: string,
  tasks: Task[],
  student: Student
): {
  score: number
  breakdown: {
    completionRate: number
    difficultyAdaptation: number
    speed: number
    mbtiBase: number
  }
  confidence: number
} {
  // 各指標を計算
  const completionRateScore = calculateSkillFromCompletionRate(studentId, category, tasks)
  const difficultyScore = calculateSkillFromDifficultyAdaptation(studentId, category, tasks)
  const speedScore = calculateSkillFromCompletionSpeed(studentId, category, tasks)
  const mbtiBase = getMBTISkillBase(student.MBTI)[category]
  
  // データの信頼度を計算
  const categoryTasks = tasks.filter(t => 
    t.category === category && t.assignee_id === studentId
  )
  const completedTasks = categoryTasks.filter(t => t.status === 'completed')
  
  // データポイントが多いほど信頼度が高い
  const dataConfidence = Math.min(1.0, completedTasks.length / 10)
  const hasSpeedData = completedTasks.some(t => t.start_date && t.end_date)
  
  // 重み付け
  // 完了率: 30%, 難易度適応: 30%, 速度: 20%, MBTI: 20%
  // ただし、データがない場合は重みを調整
  let totalWeight = 0
  let weightedSum = 0
  
  // 完了率（常に使用可能）
  weightedSum += completionRateScore * 0.3
  totalWeight += 0.3
  
  // 難易度適応（完了タスクがある場合）
  if (completedTasks.length > 0) {
    weightedSum += difficultyScore * 0.3
    totalWeight += 0.3
  } else {
    weightedSum += mbtiBase * 0.3
    totalWeight += 0.3
  }
  
  // 速度（データがある場合）
  if (hasSpeedData) {
    weightedSum += speedScore * 0.2
    totalWeight += 0.2
  } else {
    weightedSum += mbtiBase * 0.1
    totalWeight += 0.1
  }
  
  // MBTIベース（残りの重み）
  const remainingWeight = 1.0 - totalWeight
  if (remainingWeight > 0) {
    weightedSum += mbtiBase * remainingWeight
    totalWeight += remainingWeight
  }
  
  const finalScore = totalWeight > 0 ? weightedSum / totalWeight : mbtiBase
  
  return {
    score: Math.max(1, Math.min(5, Math.round(finalScore * 10) / 10)),
    breakdown: {
      completionRate: completionRateScore,
      difficultyAdaptation: difficultyScore,
      speed: speedScore,
      mbtiBase
    },
    confidence: dataConfidence
  }
}
```

**メリット**:
- 最も正確な評価
- データが少なくても評価可能
- 信頼度も提供

**デメリット**:
- 実装が複雑
- 計算コストが高い

---

## 方法6: 時系列成長の追跡

### 概要
スキルの時系列変化を追跡し、成長を評価

### 実装内容

**計算ロジック**:
```typescript
interface SkillHistory {
  date: string
  skill_企画: number
  skill_実行: number
  skill_調整: number
  skill_探索: number
}

function trackSkillGrowth(
  studentId: string,
  category: string,
  tasks: Task[]
): {
  current: number
  previous: number
  trend: 'improving' | 'declining' | 'stable'
  growthRate: number
} {
  // タスクを時系列でソート
  const sortedTasks = tasks
    .filter(t => t.category === category && t.assignee_id === studentId)
    .sort((a, b) => new Date(a.start_date || a.deadline).getTime() - new Date(b.start_date || b.deadline).getTime())
  
  // 前半と後半に分けて評価
  const midpoint = Math.floor(sortedTasks.length / 2)
  const earlyTasks = sortedTasks.slice(0, midpoint)
  const recentTasks = sortedTasks.slice(midpoint)
  
  const earlyScore = calculateSkillFromCompletionRate(studentId, category, earlyTasks)
  const recentScore = calculateSkillFromCompletionRate(studentId, category, recentTasks)
  
  const growthRate = recentScore - earlyScore
  let trend: 'improving' | 'declining' | 'stable'
  
  if (growthRate > 0.3) {
    trend = 'improving'
  } else if (growthRate < -0.3) {
    trend = 'declining'
  } else {
    trend = 'stable'
  }
  
  return {
    current: recentScore,
    previous: earlyScore,
    trend,
    growthRate
  }
}
```

**メリット**:
- 成長を可視化できる
- 学習効果を測定できる

**デメリット**:
- 十分なデータが必要
- 時間がかかる

---

## 方法7: チーム内比較による相対評価

### 概要
同じチーム内の他のメンバーと比較して相対的に評価

### 実装内容

**計算ロジック**:
```typescript
function calculateSkillRelativeToTeam(
  studentId: string,
  category: string,
  tasks: Task[],
  teamMembers: Student[]
): number {
  // 自分のスキル
  const mySkill = calculateSkillFromCompletionRate(studentId, category, tasks)
  
  // チームメンバーの平均スキル
  const teamSkills = teamMembers
    .filter(m => m.student_id !== studentId)
    .map(m => calculateSkillFromCompletionRate(m.student_id, category, tasks))
  
  if (teamSkills.length === 0) return mySkill
  
  const teamAverage = teamSkills.reduce((sum, s) => sum + s, 0) / teamSkills.length
  const teamStdDev = Math.sqrt(
    teamSkills.reduce((sum, s) => sum + Math.pow(s - teamAverage, 2), 0) / teamSkills.length
  )
  
  // Zスコアを計算
  const zScore = teamStdDev > 0 ? (mySkill - teamAverage) / teamStdDev : 0
  
  // Zスコアを1-5スケールに変換
  // Z=+1.5以上 = 5.0, Z=0 = 3.0, Z=-1.5以下 = 1.0
  const relativeScore = 3.0 + (zScore * 1.33)
  
  // 絶対評価と相対評価を組み合わせ
  const absoluteWeight = 0.7
  const relativeWeight = 0.3
  
  const finalScore = (mySkill * absoluteWeight) + (relativeScore * relativeWeight)
  
  return Math.max(1, Math.min(5, Math.round(finalScore * 10) / 10))
}
```

**メリット**:
- チーム内での位置が分かる
- 公平な評価が可能

**デメリット**:
- チーム全体のレベルに依存
- チーム間の比較が難しい

---

## 方法8: レビュー評価の活用

### 概要
タスクのレビュー評価からスキルを評価（将来的な実装）

### 実装内容

**必要なデータ構造**:
```typescript
interface TaskReview {
  task_id: string
  reviewer_id: string
  quality_score: number // 1-5
  completeness_score: number // 1-5
  timeliness_score: number // 1-5
  comments: string
}
```

**計算ロジック**:
```typescript
function calculateSkillFromReviews(
  studentId: string,
  category: string,
  tasks: Task[],
  reviews: TaskReview[]
): number {
  const categoryTasks = tasks.filter(t => 
    t.category === category && t.assignee_id === studentId
  )
  
  const taskReviews = reviews.filter(r => 
    categoryTasks.some(t => t.task_id === r.task_id)
  )
  
  if (taskReviews.length === 0) return 3.0
  
  // レビュースコアの平均
  const avgQuality = taskReviews.reduce((sum, r) => sum + r.quality_score, 0) / taskReviews.length
  const avgCompleteness = taskReviews.reduce((sum, r) => sum + r.completeness_score, 0) / taskReviews.length
  const avgTimeliness = taskReviews.reduce((sum, r) => sum + r.timeliness_score, 0) / taskReviews.length
  
  // 重み付け平均
  const skillScore = (avgQuality * 0.4) + (avgCompleteness * 0.4) + (avgTimeliness * 0.2)
  
  return Math.max(1, Math.min(5, Math.round(skillScore * 10) / 10))
}
```

**メリット**:
- 品質を評価できる
- 客観的な評価

**デメリット**:
- レビューシステムの実装が必要
- レビュワーの主観が入る可能性

---

## 方法9: 自己評価との比較

### 概要
生徒の自己評価と実績を比較してスキルを評価

### 実装内容

**計算ロジック**:
```typescript
function calculateSkillWithSelfAssessment(
  student: Student,
  category: string,
  tasks: Task[]
): {
  score: number
  selfAssessmentBias: number // 自己評価と実績の乖離度
} {
  // 実績ベースのスキル
  const performanceScore = calculateSkillFromCompletionRate(
    student.student_id,
    category,
    tasks
  )
  
  // 自己評価（strengths/weaknessesから推定）
  let selfAssessment = 3.0
  if (student.strengths.includes(category)) {
    selfAssessment = 4.0
  } else if (student.weaknesses.includes(category)) {
    selfAssessment = 2.0
  }
  
  // 乖離度を計算
  const bias = Math.abs(performanceScore - selfAssessment)
  
  // 実績と自己評価を組み合わせ
  // 実績の重みを大きく（70%）
  const finalScore = (performanceScore * 0.7) + (selfAssessment * 0.3)
  
  return {
    score: Math.max(1, Math.min(5, Math.round(finalScore * 10) / 10)),
    selfAssessmentBias: bias
  }
}
```

**メリット**:
- 自己認識の精度も評価できる
- フィードバックに活用できる

**デメリット**:
- 自己評価の精度に依存

---

## 方法10: タスクパターン分析

### 概要
タスクのパターン（難易度、カテゴリ、期限など）からスキルを評価

### 実装内容

**計算ロジック**:
```typescript
function calculateSkillFromTaskPatterns(
  studentId: string,
  category: string,
  tasks: Task[]
): number {
  const categoryTasks = tasks.filter(t => 
    t.category === category && t.assignee_id === studentId
  )
  
  // パターン分析
  const patterns = {
    // 高難易度タスクの成功率
    highDifficultySuccess: categoryTasks
      .filter(t => t.difficulty >= 4 && t.status === 'completed').length /
      Math.max(1, categoryTasks.filter(t => t.difficulty >= 4).length),
    
    // 期限遵守率
    deadlineCompliance: categoryTasks
      .filter(t => {
        if (t.status !== 'completed' || !t.deadline || !t.end_date) return false
        return new Date(t.end_date) <= new Date(t.deadline)
      }).length /
      Math.max(1, categoryTasks.filter(t => t.status === 'completed').length),
    
    // 連続成功回数
    consecutiveSuccesses: calculateConsecutiveSuccesses(categoryTasks),
    
    // タスクの多様性（様々な難易度に挑戦しているか）
    taskDiversity: calculateTaskDiversity(categoryTasks)
  }
  
  // 各パターンをスコア化
  const highDifficultyScore = patterns.highDifficultySuccess * 5
  const complianceScore = patterns.deadlineCompliance * 5
  const consecutiveScore = Math.min(5, patterns.consecutiveSuccesses * 0.5)
  const diversityScore = patterns.taskDiversity * 5
  
  // 重み付け平均
  const skillScore = (
    highDifficultyScore * 0.3 +
    complianceScore * 0.3 +
    consecutiveScore * 0.2 +
    diversityScore * 0.2
  )
  
  return Math.max(1, Math.min(5, Math.round(skillScore * 10) / 10))
}

function calculateConsecutiveSuccesses(tasks: Task[]): number {
  // 時系列でソート
  const sorted = tasks.sort((a, b) => 
    new Date(a.start_date || a.deadline).getTime() - 
    new Date(b.start_date || b.deadline).getTime()
  )
  
  let maxConsecutive = 0
  let currentConsecutive = 0
  
  for (const task of sorted) {
    if (task.status === 'completed') {
      currentConsecutive++
      maxConsecutive = Math.max(maxConsecutive, currentConsecutive)
    } else {
      currentConsecutive = 0
    }
  }
  
  return maxConsecutive
}

function calculateTaskDiversity(tasks: Task[]): number {
  const difficultyCounts: Record<number, number> = {}
  tasks.forEach(t => {
    difficultyCounts[t.difficulty] = (difficultyCounts[t.difficulty] || 0) + 1
  })
  
  // エントロピーを計算（多様性の指標）
  const total = tasks.length
  let entropy = 0
  for (const count of Object.values(difficultyCounts)) {
    const p = count / total
    if (p > 0) {
      entropy -= p * Math.log2(p)
    }
  }
  
  // 最大エントロピー（全難易度が均等）で正規化
  const maxEntropy = Math.log2(5) // 難易度1-5
  return entropy / maxEntropy
}
```

**メリット**:
- 多角的な評価
- パターンから深い洞察が得られる

**デメリット**:
- 実装が複雑
- 計算コストが高い

---

## 推奨実装順序

### フェーズ1: 基本実装（1週間）
1. **方法1: タスク完了率ベース** - 最も簡単で効果的
2. **方法4: MBTI特性による補正** - 初期値の設定

### フェーズ2: 精度向上（1週間）
3. **方法2: 難易度適応度ベース** - 難易度を考慮
4. **方法5: 複合指標による総合評価** - 複数の指標を統合

### フェーズ3: 高度な機能（2週間）
5. **方法3: 完了速度ベース** - 効率性の評価
6. **方法6: 時系列成長の追跡** - 成長の可視化

### フェーズ4: 将来的な拡張
7. **方法7: チーム内比較** - 相対評価
8. **方法8: レビュー評価の活用** - レビューシステム実装後
9. **方法9: 自己評価との比較** - フィードバック機能
10. **方法10: タスクパターン分析** - 高度な分析

---

## 実装時の注意点

1. **データの品質**: タスクデータが正確でないと評価も不正確になる
2. **データ量**: 最低3-5タスク以上で評価（それ以下はデフォルト値）
3. **重みの調整**: 実際の運用データに基づいて重みを調整
4. **キャッシュ**: 計算コストが高い場合は結果をキャッシュ
5. **段階的実装**: 一度に全部実装せず、段階的に追加

---

**最終更新**: 2025-11-17

